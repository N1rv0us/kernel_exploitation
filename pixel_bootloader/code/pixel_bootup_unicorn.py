#-*- coding:utf-8 -*-

from unicorn import *
from unicorn.arm64_const import *
import unicorn.arm_const
import capstone
import keystone
import struct


#datas for pixel6 Android S abl. copy from @eshard. thanks
fastboot_read = 0xFFFF0000F8871408
download_buffer = 0xffff000090700000
__debug_stdio_write = 0xFFFF0000F88A6D5C
fastboot_write = 0xFFFF0000F8871484
pixel_loader_entry_run = 0xFFFF0000F8813D74
stop_fastboot = 0xFFFF0000F8ACBD20

ABL_LOAD_ADDRESS = 0xFFFF0000F8800000
MEMORY_START = 0xFFFF0000F8000000
MEMORY_SIZE = 200*1024*1024
STACK_START = MEMORY_START + MEMORY_SIZE - 0x1000
PAGE_SIZE = 10*1024*1024

commands = []

disassembler = capstone.Cs(capstone.CS_ARCH_ARM64, capstone.CS_MODE_ARM)
def disas(code, addr):
    for insn in disassembler.disasm(code, addr):
        print(f"addr = 0x{insn.address}\t opstr = {insn.op_str}")


def gen_shellcode(data, address):
    ks = keystone.Ks(keystone.KS_ARCH_ARM64, keystone.KS_MODE_LITTLE_ENDIAN)
    ret = ks.asm(data, address)
    return bytes(ret[0])


# func and hook point for unicorn 
def print_stack(uc:Uc, num=20):
    sp = uc.reg_read(UC_ARM64_REG_SP)
    print(f"## STACK DUMP ##\nSP: {sp:x}")
    for idx, stack in enumerate(range(sp,sp+num*8,8)):
        if sp != 0:
            v = struct.unpack('Q', uc.mem_read(stack, 8))[0]
            print(f"@{stack:x} {v:x} - #{idx*8:x}")

        if idx >=num:
            break

def print_regs(uc:Uc):
    for reg in ["X0","X1","X2","X3","X8","X19","X20","X21","X22","X23","X24","X28","X29","X30","SP","PC"]:
        val = eval(f"uc.reg_read(UC_ARM64_REG_{reg})")
        print(f"{reg} - {val:8X}",end=" ")
    print("")

# callback for tracing instructions
def hook_code(uc:Uc, address, size, user_data):
    print("\n##### hook code #####")
    print(f"@{address:x} step size {size:x}")
    disas(uc.mem_read(address,size),address)
    print_regs(uc)
    print_stack(uc)

def hook_interrupt(uc:Uc, intno, user_data):
    print("\n ##### catch interrupt #####")

    pc = uc.reg_read(UC_ARM64_REG_SP)
    print(f"got interrupt {intno:02x} {pc:02x}")
    # uc.reg_write(UC_ARM64_REG_PC,pc+4)
    uc.emu_stop()
    return False


def hook_mem_invalid(uc:Uc, uc_mem_type, addr,size, value, user_data):
    PAGE_SIZE=10*1024*1024
    pc = uc.reg_read(UC_ARM64_REG_PC)
    start = addr & ~(PAGE_SIZE - 1)
    uc.mem_map(start, PAGE_SIZE)
    return True


def hook_fastboot_read(uc:Uc,address,size,user_data):
    dest = uc.reg_read(UC_ARM64_REG_X0)
    size = uc.reg_read(UC_ARM64_REG_X1)
    num_read = uc.reg_read(UC_ARM64_REG_X2)

    #print_stack(uc)
    #If we change PC after calling emu_stop() that won't work!
    global commands
    if len(commands):
        command = commands.pop(0)
    else:
        command = None
        
    if command == b"outofloop" or not command:
        #Once we are done, set stop_fastboot to 0 and log instructions
        uc.mem_write(stop_fastboot,struct.pack("Q",1))
        uc.reg_write(UC_ARM64_REG_X0,0xFFFFFFF0)
        uc.reg_write(UC_ARM64_REG_PC,0xFFFF0000F887143C)
    else:
        print(">>> fastboot_read",hex(dest),hex(size),hex(num_read))
        #print_stack(uc)
        uc.mem_write(num_read,struct.pack("Q",len(command)))
        uc.mem_write(dest,command)
        uc.reg_write(UC_ARM64_REG_X0,0)
        uc.reg_write(UC_ARM64_REG_PC,0xFFFF0000F887143C)


def hook_fprintf_output(uc:Uc,address,size,user_data):
    data = uc.reg_read(UC_ARM64_REG_X0)
    s = uc.mem_read(data,50)
    size = uc.reg_read(UC_ARM64_REG_X1)
    dunno = uc.reg_read(UC_ARM64_REG_X2)
    d = uc.mem_read(dunno,50)
    print(">>> hook_fprintf_output",hex(data),s,hex(size),hex(dunno),d)

def hook_stdio_write(uc:Uc,address,size,user_data):
    a = uc.reg_read(UC_ARM64_REG_X0)
    b = uc.reg_read(UC_ARM64_REG_X1)
    c = uc.reg_read(UC_ARM64_REG_X2)
    b = uc.mem_read(b,c)
    try:
        b=b.decode("utf-8")
    except Exception as e:
        b=""
    print(b,end="")


def hook_fastboot_write(uc:Uc,address,size,user_data):
    a = uc.reg_read(UC_ARM64_REG_X0)
    b = uc.reg_read(UC_ARM64_REG_X1)
    
    try:
        s = uc.mem_read(a,b).decode("utf-8")
    except Exception as e:
        s=""
    print("<<<",s)



# Herer is this script entry
def main():
    global commands

    f = open("path/to/abl", "rb")
    data = f.read()
    f.close()

    try:
        mu = Uc(UC_ARCH_ARM, UC_MODE_ARM)

        mu.mem_map(MEMORY_START, MEMORY_SIZE)
        mu.mem_map(0xd8000000, PAGE_SIZE)
        mu.mem_map(0xf8200000, PAGE_SIZE)
        mu.mem_map(0xffffffff19200000, PAGE_SIZE)
        mu.mem_map(0xfffffffff8200000, PAGE_SIZE)
        mu.mem_map(0xffff000080000000, PAGE_SIZE)
        mu.mem_map(0xffff000002000000, PAGE_SIZE)
        mu.mem_map(0xffffffff10000000, PAGE_SIZE)
        mu.mem_map(download_buffer,1024*1024*5) #download buffer

        # write machine code to be emulated to memory
        mu.mem_write(ABL_LOAD_ADDRESS, data) 

        mu.hook_add(UC_HOOK_INTR, hook_interrupt)
        mu.hook_add(UC_HOOK_MEM_INVALID, hook_mem_invalid)
        mu.hook_add(UC_HOOK_CODE, hook_fastboot_read, begin=fastboot_read,end=fastboot_read)
        mu.hook_add(UC_HOOK_CODE, hook_stdio_write, begin=__debug_stdio_write,end=__debug_stdio_write)
        mu.hook_add(UC_HOOK_CODE, hook_fastboot_write, begin=fastboot_write,end=fastboot_write)

        # emulate machine code in infinite time
        mu.reg_write(UC_ARM64_REG_SP,STACK_START)
        mu.emu_start(pixel_loader_entry_run, 0,count=40000)

        pass
    except UcError as e:
        print(f"UcError ==> {e}")